#!/bin/bash

. $HOME/bin/error_utils

usage()
{
cat << _EOF_
Usage: $(basename $0) [--help] [--recursive] [--path "SEARCH_PATH"]

Search given path for dangling symbolic links and prints them.

Default is to search current directory non-recursively.
Hidden directories and files are searched.

These directories are ignored by default:
_EOF_
for each in "$@"; do 
    echo "$each"
done
}

# Default options
search_path="."
recursive=0
prune_dirs=("help" "icons" "doc" "man") # directory names to ignore

# Get command line options 
while [ "$1" ]; do 
    case "$1" in 
        -h | --help)
            usage ${prune_dirs[@]}
            exit 0
            ;;
        -r | --recursive)
            recursive=1
            shift
            ;;
        -p | --path)
            search_path="$2"
            shift 2
            ;;
        *)
            usage ${prune_dirs[@]}
            error_msg "invalid command line option, $1" 1
            ;;
    esac
done

# Validate        
if [ ! -d "$search_path" ]; then
    error_msg "search path does not exists, '$search_path'" 1
fi

# Set command to prune unwanted directories 
prune_cmd=
if [ ${#prune_dirs[@]} -gt 0 ]; then
    prune_cmd="-type d ("
    cnt=0
    for each in "${prune_dirs[@]}"; do
        if [ $cnt -eq 0 ]; then
            prune_cmd+=" -name $each "
        else
            prune_cmd+="-o -name $each "
        fi
        cnt=$((cnt + 1))
    done
    prune_cmd+=") -prune -o"
fi

# Run
if [ $recursive -eq 0 ]; then
    symlinks=($(find "$search_path" -maxdepth 1 $prune_cmd -type l -exec test ! -e "{}" \; -print))
elif [ $recursive -eq 1 ]; then
    symlinks=($(find "$search_path" $prune_cmd -type l -exec test ! -e "{}" \; -print))
fi

if [ ${#symlinks[@]} -gt 0 ]; then
    printf '%s\n' "${symlinks[@]}"
    echo "Dangling symbolic links: ${#symlinks[@]}"
fi

exit 0

